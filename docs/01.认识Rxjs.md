## 认识Rxjs

什么是Rxjs，官网是这么定义的： **R**eactive E**x**tensions For **J**ava**S**cript

```txt
RxJS is a library for reactive programming using Observables, to make it easier to compose asynchronous or callback-based code. This project is a rewrite of Reactive-Extensions/RxJS with better performance, better modularity, better debuggable call stacks, while staying mostly backwards compatible, with some breaking changes that reduce the API surface
```

翻译过来的大致意思是：

```txt
RxJS 是一个使用可观察对象进行响应式编程的库，可以更轻松地编写异步或基于回调的代码。该项目是对 Reactive-Extensions/RxJS 的重写，具有更好的性能、更好的模块化、更好的可调试调用堆栈，同时保持大部分向后兼容，并进行了一些减少 API 表面的重大更改。
```

对于上面的翻译内容有几个关键词，可有助于大致理解Rxjs。

# 响应式编程

Reactive Programming  简称 RP。是一种**面向数据流和变化传播**的编程范式。这意味着可以在编程语言中很方便地表达**静态**或**动态**的**数据流**，而**相关的计算模型**会自动将变化的值通过数据流进行传播。

上面这段解释是从某度到的，看起来说的很简单，但是要是头一次了解估计也会劝退大部分人了。我把上面比较关键的部分加粗了一下，下面我们进一步使用代码或者场景来说明这些词汇。

## 面向数据流和变化传播

在Rxjs中，会把**任何数据**或者**需要处理的对象**都抽象为一个叫做**流**的东西，这个**流**跟文件读写模型中定义的**文件流**很相似，亦或者说你可以把这个流想象为**一根水管中的水流**。

*为什么是水管，以下会有解释*

### 场景示例

公式计算是Excel中很强大的功能之一了，设定好公式之后，只要某一单元格中的数字发生了变化，相应的单元格会自动根据设定的公式计算出最后的结果。

![sum](./assets/sum.gif)

我们可以用Rxjs中的`Subject`来模拟实现上述功能：

```ts
const a$ = new Subject<number>();						// a$ 单元格A1
const b$ = new Subject<number>();						// b$ 单元格B1
const c$ = combinLatest([a$, b$]).pipe(			// c$ 单元格C1  	pipe 的本意就是管道（水管）
	map(([a, b]) => a + b)										// pipe 中通过操作符 map 模拟设定计算公式 SUM(a + b)
);

c$.subscribe(a => {													// 订阅
  console.log('结果是：', a);
});

a$.next(1);	// a$ 发射值, 单元格A1修改值了
b$.next(2); // b$ 发射值, 单元格B1修改值了 输出结果是：3	（1 + 2 = 3）

b$.next(4); // b$ 发射值, 单元格B1修改值了 输出结果是：5  （1 + 4 = 5）

```

通过上方的代码示例可以基本了解到Rxjs中的`Subject`有哪些特点以及API

#### Subject 

Subject是一个类，继承于`Rxjs.Observable`, 需要实例化。他有`pipe`、`next`、`subscribe`方法。

*Observable 的字面意思是可观察对象，下面会解释*

`pipe`的字面意思就是管道，`pipe`中传入的参数被称作操作符（**operator**），他们就像决定数据流向 **TODO**

`next` 该方法是`Subject`才会有的实例方法，他用于发射（更改）`Subject`中的值

`subscribe` 的字面意思就是订阅，只有调用了该方法，那么该对象管道内的操作符方法才会被调用执行。

```ts
const promise = new Promise<number>(resolve => resolve(123));
promise.then(value => {
  console.log(value); // 输出123
})

const subject$ = new Subject<number>();
subject$.suscribe(value => {
  console.log(value);	// 当Subject实例方法next被调用之后，这里会输出123
})
subject$.next(123); // 发射值，当 subject$被订阅后发射值，订阅者会收到发射的值
```

#### 思考

Vue 组件中的 **TODO**

### 静态数据流

### 动态数据流

## 可观察对象

在Rxjs中，`Observable`是整个Rxjs中最关键、最核心的类，字面意思就是`可观察`, 所以属于`Observable`类型的对象都称之为`可观察对象`, 像上方代码示例中的`Subject`就是`Observable`的派生类。

虽然`Subject`与`Observable`是继承关系，但是他们的使用方式很不一样，下面是一段使用`Observable`的代码示例

```ts
const observable$ = new Observable<string>(subscribe => {  	// subscribe 类似 Promise中 resolve 和 reject的集合体
    let i = 0;
    const timer = setInterval(() =>{
        subscribe.next(i++)				// 每隔1秒发射一次值 , 这里相当于Promise.resolve()
        if (i === 10) {
            subscribe.complete();		// 
        }
    }, 1000);
    return () => {
        clearInterval(timer); // 清理
    }
});

observable$.subscribe(value => {		// 订阅 这个相当于 Promise.then()
    console.log(value);					// 每隔1秒打印一次值，打印10次之后不再打印
})

```

通过上面的代码，可以看到，Observable与Subject的区别 **TODO**

另外，由于`Observable`也可以很好的处理异步任务，所以经常会拿来跟`Promise`作比较。他们的API除了名称不一样，使用方式却非常相似。不过他们的内部执行过程完全不一样。

以下是`Observable`与`Promise`之间的区别。

|                       | Promise                                                      | Observable                                                   |
| --------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ECMAScript 标准       | ES6规范，javascript原生对象                                  | 不属于ES6规范，属于第三方库                                  |
| 支持async/await语法糖 | 支持                                                         | 不支持                                                       |
| 异步/同步任务         | 是异步任务，属于微任务                                       | 是不是异步/同步任务，取决于当前执行的代码                    |
| 执行时机              | 被实例化之后立即执行构造函数中传入的任务（函数）             | 被订阅之后才会执行                                           |
| 数据发射              | resolve() 方法只在第一次调用的时候有效，所以**只会发射一次** | `subscribe.next()`可以多次调用，直到`subscribe.complete()`或者`subscribe.error() `方法被调用后 |



## 异步或者基于回调的代码

## Reactive-Extensions

## 模块化

## 可调试调用堆栈

## 向后兼容

